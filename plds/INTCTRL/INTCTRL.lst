LISTING FOR LOGIC DESCRIPTION FILE: INTCTRL.pld                      Page 1

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Tue Apr 02 16:32:35 2024

  1:Name     INTCTRL;
  2:PartNo   INTCTRL;
  3:Date     03/30/2024;
  4:Revision 01;
  5:Designer Sponaugle;
  6:Company  Ratiometric;
  7:Assembly None;
  8:Location None;
  9:Device   f1508isptqfp100;
 10:
 11:PROPERTY ATMEL {TDI_PULLUP = ON};
 12:PROPERTY ATMEL {TMS_PULLUP = ON};
 13:PROPERTY ATMEL {PREASSIGN = KEEP};
 14:
 15:
 16:/* 
 17:                                                Inputs
 18:    ##########################################################################################
 19:*/
 20:
 21:// From CPU

 22:Pin [0..0] = [CPU_A27..8];
 23:Pin [0..0] = [CPU_A3..0];
 24:Pin  0  = CPU_RW;
 25:Pin [0..0] = [CPU_D7..0];
 26:
 27:// From Bus Controller CPLD

 28:Pin  0  = CPU_CLK;
 29:Pin  0  = nSYS_RESET;
 30:Pin  0  = nINTCTRL_CS;
 31:Pin  0  = nINT_ACK_CYCLE;           // Active low signal indicating the start of an Interrupt Acknowledge Cycle from the CPU

 32:
 33:// Incoming Interrupt Lines

 34:
 35:Pin  0  = vINT7A;
 36:Pin  0  = vINT6A,vINT6B;
 37:Pin  0  = vINT5A, vINT5B,vINT5C,vINT5D;
 38:Pin  0  = vINT4A, vINT4B,vINT4C;
 39:Pin  0  = vINT3A, vINT3B;
 40:Pin  0  = vINT2A, vINT2B;
 41:Pin  0  = vINT1A, vINT1B;
 42:
 43:/* 
 44:                                                Outputs
 45:    ##########################################################################################
 46:*/
 47:
 48:Pin [0..0] = [CPU_IPL2..0];
 49:
 50:/* 
 51:                                                Internal NODES
 52:    ##########################################################################################
 53:*/

LISTING FOR LOGIC DESCRIPTION FILE: INTCTRL.pld                      Page 2

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Tue Apr 02 16:32:35 2024

 54:NODE [INT_ACK_LEVEL2..0];       // a recording of the current interrupt acknowledged from the CPU

 55:NODE [INT_MSK15..0];            // 16 bit Interrupt Mask.  15=INT7A...0=INT1B

 56:NODE INT7A_REQUEST;
 57:NODE INT6A_REQUEST;
 58:NODE INT6B_REQUEST;
 59:NODE INT_ACK_RESET_PRE;
 60:NODE INT_ACK_RESET;
 61:
 62:// The following NODES are in place to compact the total size of some later fields.  The use of NODES adds a bit of latency

 63:// but allows the complex expressions to compile and optmize correctly.

 64:NODE INTL6_REQUEST_PE;
 65:NODE INTL5_REQUEST_PE;
 66:NODE INTL4_REQUEST_PE;
 67:NODE INTL3_REQUEST_PE;
 68:NODE INTL2_REQUEST_PE;
 69:NODE INTL1_REQUEST_PE;
 70:NODE INT5D_REQUEST_PE;
 71:NODE INT5C_REQUEST_PE;
 72:NODE INT4C_REQUEST_PE;
 73:NODE INT6B_REQUEST_PE;
 74:NODE INT5B_REQUEST_PE;
 75:NODE INT4B_REQUEST_PE;
 76:NODE INT3B_REQUEST_PE;
 77:NODE INT2B_REQUEST_PE;
 78:
 79:/* 
 80:    Interrupt Mask Register 
 81:    Byte Write to high,then low. 
 82:    1=Enable Interrupt, 0=Disable Interrupt
 83:    RESETs to all 0
 84:*/
 85:
 86:[INT_MSK15..8].ck = nINTCTRL_CS & CPU_A0;
 87:[INT_MSK7..0].ck = nINTCTRL_CS & !CPU_A0;
 88:[INT_MSK15..0].ar = !nSYS_RESET;
 89:[INT_MSK15..8].d = [CPU_D7..0].io;
 90:[INT_MSK7..0].d = [CPU_D7..0].io;
 91:
 92:/*
 93:    At the start of the Interrupt Acknowlegement Cycle we will record the interrupt level being acknowledged in the INT_ACK_LEVEL0..2 flip flops.
 94:    Those same flip flops are used during the vector generation, as well as ackowledgement clearing at the end of the ack cycle.
 95:*/
 96:
 97:[INT_ACK_LEVEL2..0].ck = !nINT_ACK_CYCLE;
 98:[INT_ACK_LEVEL2..0].ar = !nSYS_RESET;
 99:INT_ACK_LEVEL0.d = CPU_A1;
100:INT_ACK_LEVEL1.d = CPU_A2;
101:INT_ACK_LEVEL2.d = CPU_A3;
102:FIELD field_INT_ACK_LEVEL = [INT_ACK_LEVEL2..0];
103:
104:
105:// Interrupt Lines converted to Interrupt Requests (active high).  We will also integrate

106:
107:// INT7A is the debug button which is an falling edge triggered interrupt.


LISTING FOR LOGIC DESCRIPTION FILE: INTCTRL.pld                      Page 3

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Tue Apr 02 16:32:35 2024

108:INT7A_REQUEST.d = INT_MSK15;
109:INT7A_REQUEST.ck = !vINT7A;
110:INT7A_REQUEST.ar = !nSYS_RESET # (INT_ACK_RESET & INT7A_REQUEST & field_INT_ACK_LEVEL:['d'7]);         // If INT7A_REQUEST is set, and we are ack'ing a level 7, clear this.

111:
112:// INT6A and INT6B come from the PTC.  The are falling edge triggers so they need

113:// capture flip flops.

114:
115:INT6A_REQUEST.d = INT_MSK14;
116:INT6A_REQUEST.ck = !vINT6A;
117:INT6A_REQUEST.ar = !nSYS_RESET # (INT_ACK_RESET & INT6A_REQUEST_PE & field_INT_ACK_LEVEL:['d'6]);         // TOOD Needs some kind of ACK clear.

118:
119:INT6B_REQUEST.d = INT_MSK13;
120:INT6B_REQUEST.ck = !vINT6B;
121:INT6B_REQUEST.ar = !nSYS_RESET # (INT_ACK_RESET & INT6B_REQUEST_PE & field_INT_ACK_LEVEL:['d'6]);         // TOOD Needs some kind of ACK clear.

122:
123:INT5A_REQUEST = !vINT5A & INT_MSK12;        // INT5A comes from the NIC.  Active low signal.

124:INT5B_REQUEST = !vINT5B & INT_MSK11;        // INT5B and INT5C come from the IDE interfaces.  Active low signal

125:INT5C_REQUEST = !vINT5B & INT_MSK10;
126:INT5D_REQUEST = !vINT5D & INT_MSK9;         // INT5D in an expansion interrupt (undefined)  Make active low, with pullup

127:INT4A_REQUEST = vINT4A & INT_MSK8;          // INT4A is UART1.  The 2550 UARTs are active high interrupts

128:INT4B_REQUEST = vINT4B & INT_MSK7;          // INT4B is UART2.  The 2550 UARTs are active high interrupts

129:INT4C_REQUEST = !vINT4C & INT_MSK6;         // INT4C in an expansion interrupt (undefined)  Make active low, with pullup

130:INT3A_REQUEST = !vINT3A & INT_MSK5;         // INT3A comes from the FT-120 USB interface.  Active low signal.

131:INT3B_REQUEST = !vINT3B & INT_MSK4;         // INT3B in an expansion interrupt (undefined)  Make active low, with pullup

132:INT2A_REQUEST = !vINT2A & INT_MSK3;         // INT2A comed from the Video Interface, Active low signal

133:INT2B_REQUEST = !vINT2B & INT_MSK2;         // INT2B is an expansion interrupt (undefined)  Make active low, with pullup

134:INT1A_REQUEST = !vINT1A & INT_MSK1;         // INT2A comed from the Video Interface, Active low signal

135:INT1B_REQUEST = !vINT1B & INT_MSK0;         // INT2B is an expansion interrupt (undefined)  Make active low, with pullup

136:
137:/* 
138:   We will create a priority encoded version of each interrupt level so we can set the CPU_IPL0-2
139:   pins.  These are all active high signals, and only one will be active.
140:*/
141:
142:
143:INTL7_REQUEST_PE = INT7A_REQUEST;
144:INTL6_REQUEST_PE = (!INT7A_REQUEST) & (INT6A_REQUEST # INT6B_REQUEST );
145:INTL5_REQUEST_PE = (!INTL6_REQUEST_PE & !INTL7_REQUEST_PE) 
146:                 & (INT5A_REQUEST # INT5B_REQUEST # INT5C_REQUEST # INT5D_REQUEST );
147:INTL4_REQUEST_PE = (!INTL5_REQUEST_PE &!INTL6_REQUEST_PE & !INTL7_REQUEST_PE) 
148:                 & (INT4A_REQUEST # INT4B_REQUEST # INT4C_REQUEST );
149:INTL3_REQUEST_PE = (!INTL4_REQUEST_PE & !INTL5_REQUEST_PE & !INTL6_REQUEST_PE & !INTL7_REQUEST_PE) 
150:                 & (INT3A_REQUEST # INT3B_REQUEST );
151:INTL2_REQUEST_PE = (!INTL3_REQUEST_PE & !INTL4_REQUEST_PE & !INTL5_REQUEST_PE & !INTL6_REQUEST_PE & !INTL7_REQUEST_PE) 
152:                 & (INT2A_REQUEST # INT2B_REQUEST );
153:INTL1_REQUEST_PE = (!INTL2_REQUEST_PE & !INTL3_REQUEST_PE & !INTL4_REQUEST_PE & !INTL5_REQUEST_PE & !INTL6_REQUEST_PE & !INTL7_REQUEST_PE) 
154:                 & (INT1A_REQUEST # INT1B_REQUEST );
155:
156:/* 
157:    We will create the CPU_IPL signals back to the CPU.
158:*/
159:
160:CPU_IPL2 = !(INTL7_REQUEST_PE # INTL6_REQUEST_PE # INTL5_REQUEST_PE # INTL4_REQUEST_PE);
161:CPU_IPL1 = !(INTL7_REQUEST_PE # INTL6_REQUEST_PE # INTL3_REQUEST_PE # INTL2_REQUEST_PE);

LISTING FOR LOGIC DESCRIPTION FILE: INTCTRL.pld                      Page 4

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Tue Apr 02 16:32:35 2024

162:CPU_IPL0 = !(INTL7_REQUEST_PE # INTL5_REQUEST_PE # INTL3_REQUEST_PE # INTL1_REQUEST_PE);
163:
164:/* 
165:    Next we will create a set of priorty encoders for each level to pick the particular winning interrupt.
166:    In each level group only one sub interrupt will be active.
167:*/
168:
169:INT7A_REQUEST_PE = INT7A_REQUEST;
170:
171:INT6A_REQUEST_PE = INT6A_REQUEST;
172:INT6B_REQUEST_PE = !INT6A_REQUEST_PE & INT6B_REQUEST;
173:
174:INT5A_REQUEST_PE = INT5A_REQUEST;
175:INT5B_REQUEST_PE = !INT5A_REQUEST_PE & INT5B_REQUEST;
176:INT5C_REQUEST_PE = !INT5A_REQUEST_PE & !INT5B_REQUEST_PE & INT5C_REQUEST;
177:INT5D_REQUEST_PE = !INT5A_REQUEST_PE & !INT5B_REQUEST_PE & !INT5C_REQUEST_PE & INT5D_REQUEST;
178:
179:INT4A_REQUEST_PE = INT4A_REQUEST;
180:INT4B_REQUEST_PE = !INT4A_REQUEST_PE & INT4B_REQUEST;
181:INT4C_REQUEST_PE = !INT4A_REQUEST_PE & !INT4B_REQUEST_PE & INT4C_REQUEST;
182:
183:INT3A_REQUEST_PE = INT3A_REQUEST;
184:INT3B_REQUEST_PE = !INT3A_REQUEST_PE & INT3B_REQUEST;
185:
186:INT2A_REQUEST_PE = INT3A_REQUEST;
187:INT2B_REQUEST_PE = !INT2A_REQUEST_PE & INT2B_REQUEST;
188:
189:INT1A_REQUEST_PE = INT1A_REQUEST;
190:INT1B_REQUEST_PE = !INT1A_REQUEST_PE & INT1B_REQUEST;
191:
192:/* 
193:   With the per level priority encoder we can build the vector number that needs to be driven onto the CPU 
194:   data bus 
195:*/
196:
197:[CPU_D7..0].oe = !nINT_ACK_CYCLE;       // If we are in an Interrupt Ack Cycle, enable the data bus outputs.

198:
199:CPU_D7 = 'b'1;
200:CPU_D6 = INT_ACK_LEVEL2;
201:CPU_D5 = INT_ACK_LEVEL1;
202:CPU_D4 = INT_ACK_LEVEL0;
203:CPU_D3 = (INTL5_REQUEST_PE & INT5D_REQUEST_PE);
204:CPU_D2 = (INTL5_REQUEST_PE & INT5C_REQUEST_PE) # (INTL4_REQUEST_PE & INT4C_REQUEST_PE);
205:CPU_D1 = (INTL6_REQUEST_PE & INT6B_REQUEST_PE) # (INTL5_REQUEST_PE & INT5B_REQUEST_PE)
206:       # (INTL4_REQUEST_PE & INT4B_REQUEST_PE) # (INTL3_REQUEST_PE & INT3B_REQUEST_PE)
207:       # (INTL2_REQUEST_PE & INT2B_REQUEST_PE) # (INTL1_REQUEST_PE & INT1B_REQUEST_PE);
208:CPU_D0 = (INTL6_REQUEST_PE & INT6A_REQUEST_PE) # (INTL5_REQUEST_PE & INT5A_REQUEST_PE)
209:       # (INTL4_REQUEST_PE & INT4A_REQUEST_PE) # (INTL3_REQUEST_PE & INT3A_REQUEST_PE)
210:       # (INTL2_REQUEST_PE & INT2A_REQUEST_PE) # (INTL1_REQUEST_PE & INT1A_REQUEST_PE);
211:
212:
213:/* 
214:   As a last part of the interrupt acklowdegement cycle, we need to build a single cycle signal that
215:   can be used to reset the flip flop of the particular edge triggered interrupt source. 

LISTING FOR LOGIC DESCRIPTION FILE: INTCTRL.pld                      Page 5

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Tue Apr 02 16:32:35 2024

216:
217:   We know the nINT_ACK_CYCLE flag will go low at the start of the acklowdegement cycle, and go high at
218:   the end of it.  We will use that rising edge to set flag call INT_ACK_RESET_PRE.  The flag will then go into 
219:   a second flip flop called INT_ACK_RESET that is clocked on the rising edge of the CPU_CLOCK.  When that second flip
220:   flop goes to 1 it will reset the _PRE flip flp, and on the next rising edge of the CPU_CLOCK the INT_ACK_RESET flip flop 
221:   will latch in a zero.  This will generate a once CPU_CLK cycle long pulse at the end of the interrupt acklowdegement cycle. 
222:*/
223:
224:
225:
226:INT_ACK_RESET_PRE.d = 'b'1;
227:INT_ACK_RESET_PRE.ck = nINT_ACK_CYCLE;
228:INT_ACK_RESET_PRE.ar = !nSYS_RESET # INT_ACK_RESET;
229:
230:INT_ACK_RESET.d = INT_ACK_RESET_PRE;
231:INT_ACK_RESET.ck = CPU_CLK;
232:INT_ACK_RESET.ar = !nSYS_RESET;
233:
234:
235:
236:/*
237:Total dedicated input used:     3/4     (75%)
238:Total I/O pins used             34/80   (42%)
239:Total Logic cells used          44/128  (34%)
240:Total Flip-Flop used            22/128  (17%)
241:Total Foldback logic used       0/128   (0%)
242:Total Nodes+FB/MCells           42/128  (32%)
243:Total cascade used              2
244:Total input pins                26
245:Total output pins               11
246:Total Pts                       94
247:
248:*/
249:
250:
251:
252:



