Name	 INTCTRL;
PartNo   INTCTRL;
Date     03/30/2024;
Revision 01;
Designer Sponaugle;
Company  Ratiometric;
Assembly None;
Location None;
Device   f1508isptqfp100;

PROPERTY ATMEL {TDI_PULLUP = ON};
PROPERTY ATMEL {TMS_PULLUP = ON};
PROPERTY ATMEL {PREASSIGN = KEEP};


/* 
                                                Inputs
    ##########################################################################################
*/

// From CPU
Pin = [CPU_A27..8];
Pin = [CPU_A3..0];
Pin = CPU_RW;
Pin = [CPU_D7..0];

// From Bus Controller CPLD
Pin = CPU_CLK;
Pin = nSYS_RESET;
Pin = nINTCTRL_CS;
Pin = nINT_ACK_CYCLE;           // Active low signal indicating the start of an Interrupt Acknowledge Cycle from the CPU

// Incoming Interrupt Lines

Pin = vINT7A;
Pin = vINT6A,vINT6B;
Pin = vINT5A, vINT5B,vINT5C,vINT5D;
Pin = vINT4A, vINT4B,vINT4C;
Pin = vINT3A, vINT3B;
Pin = vINT2A, vINT2B;
Pin = vINT1A, vINT1B;

/* 
                                                Outputs
    ##########################################################################################
*/

Pin = [CPU_IPL2..0];

/* 
                                                Internal NODES
    ##########################################################################################
*/
NODE [INT_ACK_LEVEL2..0];       // a recording of the current interrupt acknowledged from the CPU
NODE [INT_MSK15..0];            // 16 bit Interrupt Mask.  15=INT7A...0=INT1B
NODE INT7A_REQUEST;
NODE INT6A_REQUEST;
NODE INT6B_REQUEST;
NODE INT_ACK_RESET_PRE;
NODE INT_ACK_RESET;

// The following NODES are in place to compact the total size of some later fields.  The use of NODES adds a bit of latency
// but allows the complex expressions to compile and optmize correctly.
NODE INTL6_REQUEST_PE;
NODE INTL5_REQUEST_PE;
NODE INTL4_REQUEST_PE;
NODE INTL3_REQUEST_PE;
NODE INTL2_REQUEST_PE;
NODE INTL1_REQUEST_PE;
NODE INT5D_REQUEST_PE;
NODE INT5C_REQUEST_PE;
NODE INT4C_REQUEST_PE;
NODE INT6B_REQUEST_PE;
NODE INT5B_REQUEST_PE;
NODE INT4B_REQUEST_PE;
NODE INT3B_REQUEST_PE;
NODE INT2B_REQUEST_PE;

/* 
    Interrupt Mask Register 
    Byte Write to high,then low. 
    1=Enable Interrupt, 0=Disable Interrupt
    RESETs to all 0
*/

[INT_MSK15..8].ck = nINTCTRL_CS & CPU_A0;
[INT_MSK7..0].ck = nINTCTRL_CS & !CPU_A0;
[INT_MSK15..0].ar = !nSYS_RESET;
[INT_MSK15..8].d = [CPU_D7..0].io;
[INT_MSK7..0].d = [CPU_D7..0].io;

/*
    At the start of the Interrupt Acknowlegement Cycle we will record the interrupt level being acknowledged in the INT_ACK_LEVEL0..2 flip flops.
    Those same flip flops are used during the vector generation, as well as ackowledgement clearing at the end of the ack cycle.  These will remember 
    the last interrupt ack number as these are not cleared but only reset on the next intack.
*/

[INT_ACK_LEVEL2..0].ck = !nINT_ACK_CYCLE;
[INT_ACK_LEVEL2..0].ar = !nSYS_RESET;
INT_ACK_LEVEL0.d = CPU_A1;
INT_ACK_LEVEL1.d = CPU_A2;
INT_ACK_LEVEL2.d = CPU_A3;
FIELD field_INT_ACK_LEVEL = [INT_ACK_LEVEL2..0];            // This field is just a convient way to do numerical selection of a value.


// Interrupt Lines converted to Interrupt Requests (active high).  

// INT7A is the debug button which is an falling edge triggered interrupt.
INT7A_REQUEST.d = INT_MSK15;
INT7A_REQUEST.ck = !vINT7A;
INT7A_REQUEST.ar = !nSYS_RESET # (INT_ACK_RESET & INT7A_REQUEST & field_INT_ACK_LEVEL:['d'7]);         // If INT7A_REQUEST is set, and we are ack'ing a level 7, clear this.

// INT6A and INT6B come from the PTC.  The are falling edge triggers so they need
// capture flip flops.

INT6A_REQUEST.d = INT_MSK14;
INT6A_REQUEST.ck = !vINT6A;
INT6A_REQUEST.ar = !nSYS_RESET # (INT_ACK_RESET & INT6A_REQUEST_PE & field_INT_ACK_LEVEL:['d'6]);         // TOOD Needs some kind of ACK clear.

INT6B_REQUEST.d = INT_MSK13;
INT6B_REQUEST.ck = !vINT6B;
INT6B_REQUEST.ar = !nSYS_RESET # (INT_ACK_RESET & INT6B_REQUEST_PE & field_INT_ACK_LEVEL:['d'6]);         // TOOD Needs some kind of ACK clear.

INT5A_REQUEST = !vINT5A & INT_MSK12;        // INT5A comes from the NIC.  Active low signal.
INT5B_REQUEST = !vINT5B & INT_MSK11;        // INT5B comes from the IDE #1 interfaces.  Active low signal
INT5C_REQUEST = !vINT5B & INT_MSK10;        // INT5C comes from the IDE #2 interfaces.  Active low signal
INT5D_REQUEST = !vINT5D & INT_MSK9;         // INT5D in an expansion interrupt (undefined)  Make active low, with pullup
INT4A_REQUEST = vINT4A & INT_MSK8;          // INT4A is UART1.  The 2550 UARTs are active high interrupts
INT4B_REQUEST = vINT4B & INT_MSK7;          // INT4B is UART2.  The 2550 UARTs are active high interrupts
INT4C_REQUEST = !vINT4C & INT_MSK6;         // INT4C in an expansion interrupt (undefined)  Make active low, with pullup
INT3A_REQUEST = !vINT3A & INT_MSK5;         // INT3A comes from the FT-120 USB interface.  Active low signal.
INT3B_REQUEST = !vINT3B & INT_MSK4;         // INT3B in an expansion interrupt (undefined)  Make active low, with pullup
INT2A_REQUEST = !vINT2A & INT_MSK3;         // INT2A comed from the Video Interface, Active low signal
INT2B_REQUEST = !vINT2B & INT_MSK2;         // INT2B is an expansion interrupt (undefined)  Make active low, with pullup
INT1A_REQUEST = !vINT1A & INT_MSK1;         // INT2A comed from the Video Interface, Active low signal
INT1B_REQUEST = !vINT1B & INT_MSK0;         // INT2B is an expansion interrupt (undefined)  Make active low, with pullup

/* 
   We will create a priority encoded version of each interrupt level so we can set the CPU_IPL0-2
   pins.  These are all active high signals, and only one will be active.  These three pin (CPU_IPL2-0), when set
   will actually call for an interrupt to occur on the CPU.  When the CPU sees this request it will do an interrupt 
   acknowlegment cycle as soon as the current cycle ends.   These are held active until either the device stops 
   asserting the request, or if edge triggered when the int ack cycle ends. 

   The CPU has an internal interrupt level mask, and will ignore request that are equal too or lower than that current level.  
   On powerup that level is set to 7, which should ignore all interrupts.  However level 7 is special in that it will ignore only
   level 6 and below.  That is why level 7 interrupts are called NMI (Non Maskable Interrupts).

   When an interrupt is being serviced the interrupt level mask is set to the level of the interrupt being serviced.  That prevents further interrupts 
   at that level from forcing reentry.
*/


INTL7_REQUEST_PE = INT7A_REQUEST;
INTL6_REQUEST_PE = (!INT7A_REQUEST) & (INT6A_REQUEST # INT6B_REQUEST );
INTL5_REQUEST_PE = (!INTL6_REQUEST_PE & !INTL7_REQUEST_PE) 
                 & (INT5A_REQUEST # INT5B_REQUEST # INT5C_REQUEST # INT5D_REQUEST );
INTL4_REQUEST_PE = (!INTL5_REQUEST_PE &!INTL6_REQUEST_PE & !INTL7_REQUEST_PE) 
                 & (INT4A_REQUEST # INT4B_REQUEST # INT4C_REQUEST );
INTL3_REQUEST_PE = (!INTL4_REQUEST_PE & !INTL5_REQUEST_PE & !INTL6_REQUEST_PE & !INTL7_REQUEST_PE) 
                 & (INT3A_REQUEST # INT3B_REQUEST );
INTL2_REQUEST_PE = (!INTL3_REQUEST_PE & !INTL4_REQUEST_PE & !INTL5_REQUEST_PE & !INTL6_REQUEST_PE & !INTL7_REQUEST_PE) 
                 & (INT2A_REQUEST # INT2B_REQUEST );
INTL1_REQUEST_PE = (!INTL2_REQUEST_PE & !INTL3_REQUEST_PE & !INTL4_REQUEST_PE & !INTL5_REQUEST_PE & !INTL6_REQUEST_PE & !INTL7_REQUEST_PE) 
                 & (INT1A_REQUEST # INT1B_REQUEST );

/* 
    We will create the CPU_IPL signals back to the CPU.
*/

CPU_IPL2 = !(INTL7_REQUEST_PE # INTL6_REQUEST_PE # INTL5_REQUEST_PE # INTL4_REQUEST_PE);
CPU_IPL1 = !(INTL7_REQUEST_PE # INTL6_REQUEST_PE # INTL3_REQUEST_PE # INTL2_REQUEST_PE);
CPU_IPL0 = !(INTL7_REQUEST_PE # INTL5_REQUEST_PE # INTL3_REQUEST_PE # INTL1_REQUEST_PE);

/* 
    Next we will create a set of priorty encoders for each level to pick the particular winning interrupt.
    In each level group only one sub interrupt will be active.
*/

INT7A_REQUEST_PE = INT7A_REQUEST;

INT6A_REQUEST_PE = INT6A_REQUEST;
INT6B_REQUEST_PE = !INT6A_REQUEST_PE & INT6B_REQUEST;

INT5A_REQUEST_PE = INT5A_REQUEST;
INT5B_REQUEST_PE = !INT5A_REQUEST_PE & INT5B_REQUEST;
INT5C_REQUEST_PE = !INT5A_REQUEST_PE & !INT5B_REQUEST_PE & INT5C_REQUEST;
INT5D_REQUEST_PE = !INT5A_REQUEST_PE & !INT5B_REQUEST_PE & !INT5C_REQUEST_PE & INT5D_REQUEST;

INT4A_REQUEST_PE = INT4A_REQUEST;
INT4B_REQUEST_PE = !INT4A_REQUEST_PE & INT4B_REQUEST;
INT4C_REQUEST_PE = !INT4A_REQUEST_PE & !INT4B_REQUEST_PE & INT4C_REQUEST;

INT3A_REQUEST_PE = INT3A_REQUEST;
INT3B_REQUEST_PE = !INT3A_REQUEST_PE & INT3B_REQUEST;

INT2A_REQUEST_PE = INT3A_REQUEST;
INT2B_REQUEST_PE = !INT2A_REQUEST_PE & INT2B_REQUEST;

INT1A_REQUEST_PE = INT1A_REQUEST;
INT1B_REQUEST_PE = !INT1A_REQUEST_PE & INT1B_REQUEST;

/* 
   With the per level priority encoder we can build the vector number that needs to be driven onto the CPU 
   data bus 
*/

[CPU_D7..0].oe = !nINT_ACK_CYCLE;       // If we are in an Interrupt Ack Cycle, enable the data bus outputs.

CPU_D7 = 'b'1;
CPU_D6 = INT_ACK_LEVEL2;
CPU_D5 = INT_ACK_LEVEL1;
CPU_D4 = INT_ACK_LEVEL0;
CPU_D3 = (INTL5_REQUEST_PE & INT5D_REQUEST_PE);
CPU_D2 = (INTL5_REQUEST_PE & INT5C_REQUEST_PE) # (INTL4_REQUEST_PE & INT4C_REQUEST_PE);
CPU_D1 = (INTL6_REQUEST_PE & INT6B_REQUEST_PE) # (INTL5_REQUEST_PE & INT5B_REQUEST_PE)
       # (INTL4_REQUEST_PE & INT4B_REQUEST_PE) # (INTL3_REQUEST_PE & INT3B_REQUEST_PE)
       # (INTL2_REQUEST_PE & INT2B_REQUEST_PE) # (INTL1_REQUEST_PE & INT1B_REQUEST_PE);
CPU_D0 = (INTL6_REQUEST_PE & INT6A_REQUEST_PE) # (INTL5_REQUEST_PE & INT5A_REQUEST_PE)
       # (INTL4_REQUEST_PE & INT4A_REQUEST_PE) # (INTL3_REQUEST_PE & INT3A_REQUEST_PE)
       # (INTL2_REQUEST_PE & INT2A_REQUEST_PE) # (INTL1_REQUEST_PE & INT1A_REQUEST_PE);


/* 
   As a last part of the interrupt acklowdegement cycle, we need to build a single cycle signal that
   can be used to reset the flip flop of the particular edge triggered interrupt source. 

   We know the nINT_ACK_CYCLE flag will go low at the start of the acklowdegement cycle, and go high at
   the end of it.  We will use that rising edge to set flag call INT_ACK_RESET_PRE.  The flag will then go into 
   a second flip flop called INT_ACK_RESET that is clocked on the rising edge of the CPU_CLOCK.  When that second flip
   flop goes to 1 it will reset the _PRE flip flp, and on the next rising edge of the CPU_CLOCK the INT_ACK_RESET flip flop 
   will latch in a zero.  This will generate a once CPU_CLK cycle long pulse at the end of the interrupt acklowdegement cycle. 
*/



INT_ACK_RESET_PRE.d = 'b'1;
INT_ACK_RESET_PRE.ck = nINT_ACK_CYCLE;
INT_ACK_RESET_PRE.ar = !nSYS_RESET # INT_ACK_RESET;

INT_ACK_RESET.d = INT_ACK_RESET_PRE;
INT_ACK_RESET.ck = CPU_CLK;
INT_ACK_RESET.ar = !nSYS_RESET;



/*
Total dedicated input used:	3/4 	(75%)
Total I/O pins used		35/80 	(43%)
Total Logic cells used 		49/128 	(38%)
Total Flip-Flop used 		24/128 	(18%)
Total Foldback logic used 	1/128 	(0%)
Total Nodes+FB/MCells 		48/128 	(37%)
Total cascade used 		2
Total input pins 		27
Total output pins 		11
Total Pts 			110

*/


