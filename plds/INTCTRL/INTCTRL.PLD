Name	 INTCTRL;
PartNo   INTCTRL;
Date     03/30/2024;
Revision 01;
Designer Sponaugle;
Company  Ratiometric;
Assembly None;
Location None;
Device   f1508isptqfp100;

PROPERTY ATMEL {TDI_PULLUP = ON};
PROPERTY ATMEL {TMS_PULLUP = ON};
PROPERTY ATMEL {PREASSIGN = KEEP};


/* 
                                                Inputs
    ##########################################################################################
*/

// From CPU
Pin = [CPU_A27..8];
Pin = [CPU_A3..0];
Pin = CPU_RW;
Pin = [CPU_D7..0];

// From Bus Controller CPLD
Pin = CPU_CLK;
Pin = nSYS_RESET;
Pin = nINTCTRL_CS;
Pin = nINT_ACK_CYCLE;           // Active low signal indicating the start of an Interrupt Acknowledge Cycle from the CPU

// Incoming Interrupt Lines

Pin = vINT7A;
Pin = vINT6A,vINT6B;
Pin = vINT5A, vINT5B,vINT5C,vINT5D;
Pin = vINT4A, vINT4B,vINT4C;
Pin = vINT3A, vINT3B;
Pin = vINT2A, vINT2B;
Pin = vINT1A, vINT1B;

/* 
                                                Outputs
    ##########################################################################################
*/

Pin = [CPU_IPL0..2];

/* 
                                                Internal NODES
    ##########################################################################################
*/
NODE [INT_ACK_LEVEL0..2];       // a recording of the current interrupt acknowledged from the CPU
NODE [INT_MSK15..0];            // 16 bit Interrupt Mask.  15=INT7A...0=INT1B


/* 
    Interrupt Mask Register 
    Byte Write to high,then low. 
    1=Enable Interrupt, 0=Disable Interrupt
    RESETs to all 0
*/

[INT_MSK15..8].ck = nINTCTRL_CS & CPU_A0;
[INT_MSK7..0].ck = nINTCTRL_CS & !CPU_A0;
[INT_MSK15..0].ar = !nSYS_RESET;
[INT_MSK15..8].d = [CPU_D7..0];
[INT_MSK7..0].d = [CPU_D7..0];


[INT_ACK_LEVEL0..2].ck = !nINT_ACK_CYCLE
[INT_ACK_LEVEL0..2].ar = !nSYS_RESET;
INT_ACK_LEVEL0.d = CPU_A1;
INT_ACK_LEVEL1.d = CPU_A2;
INT_ACK_LEVEL2.d = CPU_A3;


// Interrupt Lines converted to Interrupt Requests (active high).  We will also integrate

// INT7A is the debug button which is an falling edge triggered interrupt.
INT7A_REQUEST.d = INT_MSK15;
INT7A_REQUEST.ck = !vINT7A;
INT7A_REQUEST.ar = !nSYS_RESET;         // TOOD Needs some kind of ACK clear.

// INT6A and INT6B come from the PTC.  The are falling edge triggers so they need
// capture flip flops.

INT6A_REQUEST.d = INT_MSK14;
INT6A_REQUEST.ck = !vINT6A;
INT6A_REQUEST.ar = !nSYS_RESET;

INT6B_REQUEST.d = INT_MSK13;
INT6B_REQUEST.ck = !vINT6B;
INT6B_REQUEST.ar = !nSYS_RESET;

INT5A_REQUEST = !vINT5A & INT_MSK12;        // INT5A comes from the NIC.  Active low signal.
INT5B_REQUEST = !vINT5B & INT_MSK11;        // INT5B and INT5C come from the IDE interfaces.  Active low signal
INT5C_REQUEST = !vINT5B & INT_MSK10;
INT5D_REQUEST = !vINT5D & INT_MSK9;         // INT5D in an expansion interrupt (undefined)  Make active low, with pullup
INT4A_REQUEST = vINT4A & INT_MSK8;          // INT4A is UART1.  The 2550 UARTs are active high interrupts
INT4B_REQUEST = vINT4B & INT_MSK7;          // INT4B is UART2.  The 2550 UARTs are active high interrupts
INT4C_REQUEST = !vINT4C & INT_MSK6;         // INT4C in an expansion interrupt (undefined)  Make active low, with pullup
INT3A_REQUEST = !vINT3A & INT_MSK5;         // INT3A comes from the FT-120 USB interface.  Active low signal.
INT3B_REQUEST = !vINT3B & INT_MSK4;         // INT3B in an expansion interrupt (undefined)  Make active low, with pullup
INT2A_REQUEST = !vINT2A & INT_MSK3;         // INT2A comed from the Video Interface, Active low signal
INT2B_REQUEST = !vINT2B & INT_MSK2;         // INT2B is an expansion interrupt (undefined)  Make active low, with pullup
INT1A_REQUEST = !vINT1A & INT_MSK1;         // INT2A comed from the Video Interface, Active low signal
INT1B_REQUEST = !vINT1B & INT_MSK0;         // INT2B is an expansion interrupt (undefined)  Make active low, with pullup

/* 
   We will create a priority encoded version of each interrupt level so we can set the CPU_IPL0-2
   pins.  These are all active high signals, and only one will be active.
*/

INTL7_REQUEST_PE = INT7A_REQUEST;
INTL6_REQUEST_PE = (!INT7A_REQUEST) & (INT6A_REQUEST # INT6B_REQUEST );
INTL5_REQUEST_PE = (!INTL6_REQUEST_PE & !INTL7_REQUEST_PE) 
                 & (INT5A_REQUEST # INT5B_REQUEST # INT5C_REQUEST # INT5D_REQUEST );
INTL4_REQUEST_PE = (!INTL5_REQUEST_PE &!INTL6_REQUEST_PE & !INTL7_REQUEST_PE) 
                 & (INT4A_REQUEST # INT4B_REQUEST # INT4C_REQUEST );
INTL3_REQUEST_PE = (!INTL4_REQUEST_PE & !INTL5_REQUEST_PE & !INTL6_REQUEST_PE & !INTL7_REQUEST_PE) 
                 & (INT3A_REQUEST # INT3B_REQUEST );
INTL2_REQUEST_PE = (!INTL3_REQUEST_PE & !INTL4_REQUEST_PE & !INTL5_REQUEST_PE & !INTL6_REQUEST_PE & !INTL7_REQUEST_PE) 
                 & (INT2A_REQUEST # INT2B_REQUEST );
INTL1_REQUEST_PE = (!INTL2_REQUEST_PE & !INTL3_REQUEST_PE & !INTL4_REQUEST_PE & !INTL5_REQUEST_PE & !INTL6_REQUEST_PE & !INTL7_REQUEST_PE) 
                 & (INT1A_REQUEST # INT1B_REQUEST );

/* 
    We will create the CPU_IPL signals back to the CPU.
*/

CPU_IPL2 = !(INTL7_REQUEST_PE # INTL6_REQUEST_PE # INTL5_REQUEST_PE # INTL4_REQUEST_PE);
CPU_IPL1 = !(INTL7_REQUEST_PE # INTL6_REQUEST_PE # INTL3_REQUEST_PE # INTL2_REQUEST_PE);
CPU_IPL0 = !(INTL7_REQUEST_PE # INTL5_REQUEST_PE # INTL3_REQUEST_PE # INTL1_REQUEST_PE);

/* 
    Next we will create a set of priorty encoders for each level to pick the particular winning interrupt.
    In each level group only one sub interrupt will be active.
*/

INT7A_REQUEST_PE = INT7A_REQUEST;

INT6A_REQUEST_PE = INT6A_REQUEST;
INT6B_REQUEST_PE = !INT6A_REQUEST_PE & INT6B_REQUEST;

INT5A_REQUEST_PE = INT5A_REQUEST;
INT5B_REQUEST_PE = !INT5A_REQUEST_PE & INT5B_REQUEST;
INT5C_REQUEST_PE = !INT5A_REQUEST_PE & !INT5B_REQUEST_PE & INT5C_REQUEST;
INT5D_REQUEST_PE = !INT5A_REQUEST_PE & !INT5B_REQUEST_PE & !INT5C_REQUEST_PE & INT5D_REQUEST;

INT4A_REQUEST_PE = INT4A_REQUEST;
INT4B_REQUEST_PE = !INT4A_REQUEST_PE & INT4B_REQUEST;
INT4C_REQUEST_PE = !INT4A_REQUEST_PE & !INT4B_REQUEST_PE & INT4C_REQUEST;

INT3A_REQUEST_PE = INT3A_REQUEST;
INT3B_REQUEST_PE = !INT3A_REQUEST_PE & INT3B_REQUEST;

INT2A_REQUEST_PE = INT3A_REQUEST;
INT2B_REQUEST_PE = !INT2A_REQUEST_PE & INT2B_REQUEST;

INT1A_REQUEST_PE = INT1A_REQUEST;
INT1B_REQUEST_PE = !INT1A_REQUEST_PE & INT1B_REQUEST;

/* 
   With the per level priority encoder we can build the vector number that needs to be driven onto the CPU 
   data bus 
*/


