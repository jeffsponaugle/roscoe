Name	 BUSCTRL;
PartNo   BUSCTRL;
Date     03/30/2024;
Revision 01;
Designer Sponaugle;
Company  Ratiometric;
Assembly None;
Location None;
Device   f1508ispplcc84;

PROPERTY ATMEL {TDI_PULLUP = ON};
PROPERTY ATMEL {TMS_PULLUP = ON};
PROPERTY ATMEL {PREASSIGN = KEEP};


/* NOTE:  Active low values are designated with a starting n. */

/* 
                                                Inputs
    ##########################################################################################
*/ */
Pin = [CPU_FC0..2];
Pin = [CPU_A31..20];
Pin = [CPU_SIZ0..1];
Pin = [CPU_AA1..0];
Pin = nCPU_ECS;
Pin = CPU_RW;
Pin = nCPU_AS;
Pin = nSYS_RESET_IN;
Pin = CLK_IN;

/* 
                                                Outputs 
   ##########################################################################################
*/

// To CPU
Pin = [nCPU_DSACK0..1];
Pin = CPU_CIIN;
Pin = nSYS_RESET;
Pin = nCPU_HALT;
Pin = nCPU_BERR;
Pin = nCPU_STERM;
Pin = CPU_CLK;

// To SRAM

Pin = nSRAM_BANK1_CE;
Pin = nSRAM_BANK2_CE;
Pin = nSRAM_BANK3_CE;
Pin = nSRAM_BANK4_CE;
Pin = nSRAM_LL_SEL;
Pin = nSRAM_LH_SEL;
Pin = nSRAM_UL_SEL;
Pin = nSRAM_UH_SEL;
Pin = nSRAM_OE;
Pin = nSRAM_WE;

// To Devices
Pin = nDEV8BITCS;
Pin = nDEV16BITCS;
Pin = nDEV32BITCS;




/* 
    Clock Generation:
    We assume an input clock in CLK_IN that is 2 times the target CPU speed.
    CPU_CLK is the CPU Clock, which is a flip-flop toggeled by the CLK_IN rising edge.
    CPU_CLK is is not held in reset during a SYS_RESET event, so the CPU will have a clock running 
    all of the time.

    We will also generate some subdivisor clocks to use in the DRAM system.
*/

CPU_CLK.d = !CPU_CLK;               /* [16],20,25,33,40 Mhz */
CPU_CLK.ck = CLK_IN;

CPU_CLK_div2.d = !CPU_CLK_div2;     /* [8],10,12.5,16.5,20 Mhz */
CPU_CLK_div2.ck = CPU_CLK;

CPU_CLK_div4.d = !CPU_CLK_div4;     /* [4],5,6.25,8.25,10 Mhz */
CPU_CLK_div4.ck = CPU_CLK_div2;

CPU_CLK_div8.d = !CPU_CLK_div8;     /* [2],2.5,3.125,4.125,5 Mhz */
CPU_CLK_div8.ck = CPU_CLK_div4;



/* 
   System Reset Control:

   SYS_RESET_IN is an input signal that comes from a reset button or reset controller (DS1288).  It is an active low signal
   that indicated a system reset.  When this line goes low the SYS_RESET output will instantly go low.  SYS_RESET will only 
   come out of reset on the falling edge of the CPU_CLK.

   This logic will guarentee the first CPU_CLK edge after reset is a rising edge 
   This makes it possible to have deterministic behaviour on reset startup.

*/

nSYS_RESET.d = 'b'1;
nSYS_RESET.ar = nSYS_RESET_IN;
nSYS_RESET.ck = !CPU_CLK;

/* 
    Memory Bank Selection Logic:

    During a write operation the CPU will indicate via the SIZE0-1 and A0-1 pins the number of bytes being written
    and the location of the writes on theh 32 bit databus.  It is possible for the CPU to write to a single byte location 
    inside of a 32 bit wide memory.  As such we need to have individual control over which part of the data bus is 
    participating in a write. 

    It is important to note that for cacheable areas of memory (which in our design is all of the SRAM and 
    DRAM areas) - All read operations are 32 Bus Access, and all read operations must return all 4 bytes based 
    on the address bus.  This is to guarentee the cache always has the correct full 32 value for an addresss.

    SEE DATASHEET for TABLE

    For 32bit Bus Write Access:
            BA32_LL = Active high flag for the LSB 8 bits, located on D31:D24
            BA32_LH = Active high flag for the second LSB 8 bits, located on D23:D16
            BA32_UL = Active high flag for the lower MSB 8 bits, located on D15:D8
            BA32_UH = Active high flag for the upper MSB 8 bits, located on D7:D0

    For 16bit Bus  Write Access:
            BA16_LL = Active high flag for the LSB 8 bits, located on D31:D24
            BA16_LH = Active high flag for the MSB 8 bits, located on D23:D16

    For 8bit Bus  Write Access:
            BA8 = Active high for all accesses, so hard coded to 1, located on D31:24

*/

BA32_LL = (!CPU_AA0 & !CPU_AA1);
BA32_LH = !((CPU_AA1 # (!CPU_AA0 & CPU_SIZ0 & !CPU_SIZ1)));
BA32_UL = !(( (!CPU_AA1 & CPU_SIZ0 & !CPU_SIZ1) 
            # (CPU_AA2 & CPU_AA1) 
            # (!CPU_AA0 & !CPU_AA1 & !CPU_SIZ0 & CPU_SIZ1)
           ));
BA32_UH = (   (CPU_AA1 & CPU_SIZ1) 
            # (!CPU_SIZ1 & !CPU_SIZ0) 
            # (CPU_AA0 & CPU_SIZ1 & CPU_SIZ0) 
            # (CPU_AA0 & CPU_AA1)
          );

BA16_LL = !CPU_AA0;
BA16_LH = !(!CPU_AA0 & CPU_SIZ0 & !CPU_SIZ1);

BA8 = 'b'1;

/* 
    Region selection logic:

    These variables are active high indicators of access to a particular area of memory.

    DRAM_REGION_ACCESS - Any access to the upper 2GB of address space
    FLASH_REGION_ACCESS - Any access to 0x0000 0000 to 0x0FFF FFFF
    SRAM_REGION_ACCESS - Any access to 0x1000 0000 to 0x1FFF FFFF
    DEV8BIT_REGION_ACCESS - Any access to 0x3000 0000 to 0x3FFF FFFF
    DEV16BIT_REGION_ACCESS - Any access to 0x4000 0000 to 0x4FFF FFFF
    DEV32BIT_REGION_ACCESS - Any access to 0x5000 0000 to 0x5FFF FFFF
    VIDEO_REGION_ACCESS - Any access to 0x6000 0000 to 0x7FFF FFFF

*/

DRAM_REGION_ACCESS = !CPU_AS & CPU_A31;                                     // 0x8000 0000 - 0xFFFF FFFF
FLASH_REGION_ACCESS = !CPU_AS & !CPU_A31 & !CPU_A30 & !CPU_A29 & !CPU_A28;  // 0x0000 0000 - 0x0FFF FFFF
SRAM_REGION_ACCESS = !CPU_AS & !CPU_A31 & !CPU_A30 & !CPU_A29 & CPU_A28;    // 0x1000 0000 - 0x1FFF FFFF
DEV8BIT_REGION_ACCESS = !CPU_AS & !CPU_A31 & !CPU_A30 
                        & CPU_A29 & CPU_A28;                                // 0x3000 0000 - 0x3FFF FFFF
DEV16BIT_REGION_ACCESS = !CPU_AS & !CPU_A31 & CPU_A30 
                        & !CPU_A29 & !CPU_A28;                              // 0x4000 0000 - 0x4FFF FFFF
DEV32BIT_REGION_ACCESS = !CPU_AS & !CPU_A31 & CPU_A30 
                        & !CPU_A29 & CPU_A28;                               // 0x5000 0000 - 0x5FFF FFFF
VIDEO_REGION_ACCESS = !CPU_AS & !CPU_A31 & CPU_A30 & CPU_A29;               // 0x6000 0000 - 0x7FFF FFFF


/*
    DSACK Generation 

    This logic generates the two DSACK signals back to the CPU.  These 2 signals are used to both indicated the need for 
    an additional wait state as well as to signal if the bus transfer is going to a device that supports 32 bits, 16 bits,
    or 8 bits.

    This logic relies on the xxxx_REGION_ACCESS variables above to know which combination of DSACK signals to apply.
    Since in this initial system both the DRAM and SRAM are 0 WS, the logic will always assert the correct DSACK
    combination as soon as the above xxxx_REGION_ACCESS variables are active.  That should happen directly after the 
    CPU_AS signal goes low.

    Transfer Size      DSACK1   DSACK0
    8 bit               1          0            DEV8BIT,FLASH
    16 bit              0          1            DEV16BIT
    32 bit              0          0            DEV32BIT,DRAM,SRAM

    Since the xxxx_REGION_ACCESS variables contain CPU_AS, these DSACK signals will go low shortly after AS, but then 
    go high when AS returns to high at the end of the cycle.   The address bits are guarenteed to be stable before AS 
    goes low and held stable until AS goes high.

*/

nCPU_DSACK0 = !( DRAM_REGION_ACCESS # SRAM_REGION_ACCESS # DEV32BIT_REGION_ACCESS # DEV8BIT_REGION_ACCESS);
nCPU_DSACK1 = !( DRAM_REGION_ACCESS # SRAM_REGION_ACCESS # DEV32BIT_REGION_ACCESS # DEV16BIT_REGION_ACCESS);



/*
    SRAM signaling

    Control signals for SRAM - 

        There are 4 banks of SRAM, and each bank is 2 IC that are 16 bits wide.  Each IC has a CE, WE, OE, 
        UB, LB.  Since this SRAM region is cacheable all reads are 32 bits regardless of the internal 
        operation in the CPU.  Writes however must be controlled by the 8 bit section using the 
        "Memory Bank Selection Logic" from above.

        Each bank is 1MB of address space.

        nSRAM_BANK1_CE -> 0x1000 0000 - 0x100F FFFF  [1MB]
        nSRAM_BANK2_CE -> 0x1010 0000 - 0x101F FFFF  [1MB]
        nSRAM_BANK3_CE -> 0x1020 0000 - 0x102F FFFF  [1MB]
        nSRAM_BANK4_CE -> 0x1030 0000 - 0x103F FFFF  [1MB]

        nSRAM_LL_SEL
        nSRAM_LH_SEL
        nSRAM_UL_SEL
        nSRAM_UH_SEL
        nSRAM_OE
        nSRAM_WE
*/

nSRAM_BANK1_CE = !SRAM_REGION_ACCESS # CPU_A27 # CPU_A26 # CPU_A25 # CPU_A24 # CPU_A23 # CPU_A22 # CPU_A21 # CPU_A20;
nSRAM_BANK2_CE = !SRAM_REGION_ACCESS # CPU_A27 # CPU_A26 # CPU_A25 # CPU_A24 # CPU_A23 # CPU_A22 # CPU_A21 # !CPU_A20;
nSRAM_BANK3_CE = !SRAM_REGION_ACCESS # CPU_A27 # CPU_A26 # CPU_A25 # CPU_A24 # CPU_A23 # CPU_A22 # !CPU_A21 # CPU_A20;
nSRAM_BANK4_CE = !SRAM_REGION_ACCESS # CPU_A27 # CPU_A26 # CPU_A25 # CPU_A24 # CPU_A23 # CPU_A22 # !CPU_A21 # !CPU_A20;

nSRAM_OE = !CPU_RW;         // Can be enabled even when not doing SRAM access because above CE is also required.
nSRAM_WE = CPU_RW;          // WE can also be enabled for all writes since both CE and one of the UB or LB must also 
                            // be low. 

// For each of the 4 bank selects, if we are doing a read it will be selected(low), and if we are doing a write
// it will depend on the value of the BA32_xx functions.  This will enable the correct byte section during a write
// based on the CPU indicating a BYTE, WORD, and DWORD write as well as the misalignment of that write.


nSRAM_LL_SEL = !(CPU_RW # BA32_LL);
nSRAM_LH_SEL = !(CPU_RW # BA32_LH);
nSRAM_UL_SEL = !(CPU_RW # BA32_UL);
nSRAM_UH_SEL = !(CPU_RW # BA32_UH);

/* 
    Device Chip Select Logic:

        These chip selects indicate the 8,16, or 32 device region.  All devices in those regions must do transfers
        of the particular region size.  This chip select can be used in decode logic combined with the lower address 
        lines to create the actual device chip selects.

        In this first iteration there is no feedback mechinism for the devices to ask for waitstates, but that 
        will be added later.

*/

nDEV8BITCS = DEV8BIT_REGION_ACCESS;
nDEV16BITCS = DEV16BIT_REGION_ACCESS;
nDEV32BITCS = DEV32BIT_REGION_ACCESS;

/* 
    DRAM Access Logic:

    This logic will allow control of 60ns FPM/EDO DRAM.  This design is configured for 8 single or dual rake 
    SIMM slots, and in this first iteration configured for 11 bits of row/column address.

*/

/*  
    This DRAM_ACCESS_RAS flip flop is the master access RAS signal.  It goes low at the start of a 
    DRAM cycle (as indicated by the DRAM_REGION_ACCESS going high).  It is reset by a RAS_RESET2 flag
    that is based on two further flip flips that count down two clock cycles.  In this design the RAS
    signal will go low at the start of the /AS cycle, and go high after two sucsessive falling edges
    of the CPU clock.
*/
nDRAM_ACCESS_RAS.d = 'b'0;
nDRAM_ACCESS_RAS.ap = DRAM_ACCESS_RAS_RESET2 # !SYS_RESET;
nDRAM_ACCESS_RAS.ck = DRAM_REGION_ACCESS;

/* 
    The two RAS RESET flip flops are held in reset until the DRAM_ACCESS_RAS goes low.   After two 
    successive CPU_CLK negative edges the DRAM_ACCESS_RAS will be set back to 1 by RESET2.
*/
DRAM_ACCESS_RAS_RESET1.d = 'b'1;
DRAM_ACCESS_RAS_RESET1.ar = nDRAM_ACCESS_RAS # !SYS_RESET;
DRAM_ACCESS_RAS_RESET1.ck = !CPU_CLK;

DRAM_ACCESS_RAS_RESET2.d = 'DRAM_ACCESS_RAS_RESET1;
DRAM_ACCESS_RAS_RESET2.ar = nDRAM_ACCESS_RAS # !SYS_RESET;
DRAM_ACCESS_RAS_RESET2.ck = !CPU_CLK;

/*
    The CAS signal is generated by using the above RAS_RESET1 signal, which occurs on the first negative clock
    edge after RAS falls, to start the CAS signal.   This guarentees the CAS signal is after RAS with enough
    time, and that the CAS to data has enough time as well.  CAS is reset to 1 at the end of the cycle via 
    the DRAM_REGION_ACCESS signal.
*/

nDRAM_ACCESS_CAS.d = 'b'0;
nDRAM_ACCESS_CAS.ap = !DRAM_REGION_ACCESS # !SYS_RESET;
nDRAM_ACCESS_CAS.ck = DRAM_ACCESS_RAS_RESET1

/*
    The third critical signal for DRAM access is the MUX signal which switches the address lines on the DRAM
    from the ROW to the COLUMN address.  This much be done after the RAS signal has gone to 0, and before the 
    CAS signal goes to 0.  There is RAS holdtime requirement of 10ns, and CAS setup requirement if 10ns, and a 
    MUX propegation delay of at least 7ns.

    The solution is the change the MUX signal based on the DRAM_ACCESS_RAS signal.  As soon as the RAS signal goes low, 
    the MUX signal will start to change.  The MUX change will be 7.5ns behind the RAS signal, and the MUX itself
    will take another 7ns to change outputs.  This will give the needed RAS hold time.

    MUX = 0 for ROW address, 1 for COL address.  Reset puts it at 0. 
*/

DRAM_ACCESS_MUX.d = 'b'1;
DRAM_ACCESS_MUX.ar = !DRAM_REGION_ACCESS # !SYS_RESET;
DRAM_ACCESS_MUX.ck = !DRAM_ACCESS_RAS;


